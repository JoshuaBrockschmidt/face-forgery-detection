#!/usr/bin/env python3

"""
Plots data from the CSV file generated by `scripts/experiments/test-grouping.py`.
Creates a heatmap of the accuracies for each model against all classes.
"""

import argparse
import csv
import matplotlib.pyplot as plt
import numpy as np
import os
from sys import stderr

from common import CLASS_TO_LABEL

HEADERS = ('mtype', 'classes', 'real', 'df', 'f2f', 'fs', 'gann', 'icf', 'x2f')
HINDEX = {v: i for i, v in enumerate(HEADERS)}

CLASSES = ('real', 'df', 'f2f', 'fs', 'icf', 'gann', 'x2f')

def load_model_data(csv_path):
    """
    Loads model results from a CSV file created by
    `scripts/experiments/test-grouping.py`.

    Args:
        csv_path: Path to CSV file.

    Returns:
        A dictionary mapping model name -> classes -> tested class -> recall
    """
    models = {}
    with open(csv_path, 'r') as f:
        reader = csv.reader(f, delimiter=',', quotechar='"')

        # Skip the headers.
        next(reader)

        for row in reader:
            mtype = row[HINDEX['mtype']]
            classes = row[HINDEX['classes']]

            if mtype not in models:
                models[mtype] = {}

            test_results = {}
            for test_class in CLASSES:
                test_results[test_class] = row[HINDEX[test_class]]

            models[mtype][classes] = test_results

    return models

def plot_heatmap(models):
    """
    Creates a heatmap of the accuracies for each model against all classes.
    """
    fig, ax = plt.subplots()
    ax.set_xlabel('Class Tested On')
    ax.set_ylabel('Classes Trained On')

    z = []
    ylabels = []
    for m in models:
        # Build labels.
        ylabels = []
        ylabel_to_key = {}
        for name in models[m]:
            classes = name.split(',')
            labels = [CLASS_TO_LABEL[c] for c in classes]
            if len(labels) == len(CLASSES) - 1:
                label = 'All'
            else:
                label = ', '.join(labels)
            ylabels.append(label)
            ylabel_to_key[label] = name
        ylabels.sort()
        ylabels.reverse()

        for label in ylabels:
            # Get accuracies.
            classes_str = ylabel_to_key[label]
            model = models[m][classes_str]
            row = []
            for test_class in CLASSES:
                if test_class not in model:
                    acc = 0
                else:
                    acc = float(model[test_class])
                row.append(acc)
            z.append(row)

    z = np.array(z)
    heatmap = ax.pcolor(z, cmap=plt.get_cmap('Purples'))
    fig.colorbar(heatmap)

    # Add class labels.
    xlabels = [CLASS_TO_LABEL[c] for c in CLASSES]
    ax.set_xticks(np.arange(0, z.shape[1]) + 0.5)
    ax.set_yticks(np.arange(0, z.shape[0]) + 0.5)
    ax.set_xticklabels(xlabels, rotation=45, ha='right')
    ax.set_yticklabels(ylabels)

    # Make more room for labels.
    fig.subplots_adjust(left=0.2, bottom=0.25)

    # Write accuracies in each cell.
    heatmap.update_scalarmappable()
    paths = heatmap.get_paths()
    colors = heatmap.get_facecolors()
    for p, color, acc in zip(paths, colors, heatmap.get_array()):
        if np.all(color[:3] > 0.5):
            text_color = (0, 0, 0)
        else:
            text_color = (1, 1, 1)
        x, y = p.vertices[:-1, :].mean(0)
        ax.text(x + 0.1, y, '%.3f' % acc, ha='center', color=text_color)

    return fig, ax

def main(csv_path):
    """
    Creates and displays heatmap using the supplied experimentation data.
    """
    models = load_model_data(csv_path)

    plot_heatmap(models)
    plt.show()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Tests a model')
    parser.add_argument('input', type=str, nargs=1,
                        help='path to CSV file with transfer learning data')
    args = parser.parse_args()

    csv_path = args.input[0]

    if not os.path.isfile(csv_path):
        print('"{}" is not a file'.format(csv_path), file=stderr)
        exit(2)

    main(csv_path)
